---
layout: post
title: Regex
description: Regular expressions in 1 hour or less
categories: [Technology]
tags: [programming, string manipulation]
image: /assets/blog/img/find-dialog.png
---

    /^([^,]+),\s([A-Z]{2})(?:\s(\d{5}))?$/

When you first encounter regular expressions ("regex") like the one above, they can seem very foreign. The random symbols look more like something from Stargate than from English, but understanding regex is actually quite simple!

# What?

Regex is a sequence of characters that form a search pattern that can be either extremely broad or specific. It is a formalized description of a regular language [created by Steven Kleene in the 1950’s](https://en.wikipedia.org/wiki/Regular_language). The theory behind is pretty cool but honestly not very relevant to our understanding.

For our purposes, regex is a way to match strings with patterns using concise code that is common across programming languages.*

# Why?

Any search you do probably at some level uses regexp to find a match. Regex is a combination of characters and meta-characters used for:

1. **Matching:** Determine if a string matches some format (e.g., a phone number, email, address or credit card number)
2. **Replacement:** Find and replace patterns in a string (e.g., all whitespaces, common mispellings, etc.)
3. **Extraction:** Extract specific information (e.g., zip codes, titles, etc.)

Using regex over code has two main advantages:

1. **Portability:** Almost every major language has a regular expression library with standardized syntax so you can learn it once, use it everywhere
2. **Concise:** While it may not seem like it at first, regex is much easier to write and read than the equivalent logic in code

Some common use cases are:

1. Verify the structure of strings (e.g. input forms)
2. Extract information form strings (e.g. zip code from an address)
3. Search / replace / rearrange parts of the string (e.g. DD/MM/YYYY to MM/DD/YYYY)
4. Split a string into tokens

# How?

Let's learn Regex with Javascript and then we can port that knowledge to other languages as needed.*

If you know the pattern beforehand, you can declare a regex using a literal. Nothing magical here--just like wrapping text in quotation marks indicates a string, or brackets indicate an array, or curly braces indicate an object, wrapping text in <span class="bottom-border">forward slashes</span> indicates a regex:
<code>var regex = <span class="bottom-border">/</span><span class="bottom-border pink">pattern</span><span class="bottom-border">/</span></code>

If you won't know the pattern till runtime (e.g. because the user will input it), you can use the RegExp constructor instead:
<code>var userInput = '<span class="bottom-border pink">pattern</span>';</code>
<code>var regex = new RegExp(userInput);</code>

The most basic operations you can do resemble the 'Ctrl / Cmd + F' operations most people are already familiar with.

![Find and Replace](/assets/blog/img/find-dialog.png)

<pre><code>var string = '<span class="bottom-border pink">Zoo</span>';
var regex = /<span class="bottom-border pink">Zoo</span>/;

string.match(regex); <span class="code-comment js">["Zoo"]</span>

'Some other word'.match(regex); <span class="code-comment js">null</span>
</code></pre>

Regex returns an array of the matched characters if there are any, or null if there are no matches.

By default, partial matches are allowed:
<code>'<span class="bottom-border pink">Zoo</span>lander'.match(regex); <span class="code-comment js">["Zoo"]</span></code>

<p class="no-bottom-spacing">To match whole words, use <span class="bottom-border blue">\b</span> to define the word boundary:</p>
<pre class="no-top-spacing"><code>'<span class="bottom-border pink">Zoo</span>lander'.match(/<span class="bottom-border blue">\b</span><span class="bottom-border pink">Zoo</span><span class="bottom-border blue">\b</span>/); <span class="code-comment js">null</span>

'San Francisco<span class="bottom-border blue"> </span><span class="bottom-border pink">Zoo</span><span class="bottom-border blue"> </span>is so cool'.match(/<span class="bottom-border blue">\b</span><span class="bottom-border pink">Zoo</span><span class="bottom-border blue">\b</span>/); <span class="code-comment js">["Zoo"]</span></code></pre>

<p class="no-bottom-spacing">By default, matches are case sensitive. Adding the <span class="bottom-border brown">i</span> modifier makes the match case insensitive:</p>
<pre class="no-top-spacing"><code>'zoo'.match(/<span class="bottom-border pink">Zoo</span>/); <span class="code-comment js">null</span>

'<span class="bottom-border pink">Zoo</span>'.match(/<span class="bottom-border pink">Zoo</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Zoo"]</span>

'<span class="bottom-border pink">zoo</span>'.match(/<span class="bottom-border pink">Zoo</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["zoo"]</span></code></pre>

There are a few more modifiers--they always go after the ending <span class="bottom-border">forward slash</span>.

By default, regex is like a *Find Next*--it stops looking as soon as a match is found. Adding the <span class="bottom-border green">g</span> modifier makes it more like a *Find All*:
<code>'<span class="bottom-border pink">Zoo</span>lander went to the SF <span class="bottom-border pink">Zoo</span>'.match(/<span class="bottom-border pink">Zoo</span>/); <span class="code-comment js">["Zoo"]</span></code>
<code>'<span class="bottom-border pink">Zoo</span>lander went to the SF <span class="bottom-border pink">Zoo</span>'.match(/<span class="bottom-border pink">Zoo</span>/<span class="bottom-border green">g</span>); <span class="code-comment js">["Zoo", "Zoo"]</span></code>

Now, let's get into the cooler stuff regex can do that goes beyond a simple *Find* function.

For one, you can search for match two separate patterns using the <span class="bottom-border">or</span> operator:
<code>'<span class="bottom-border turquoise">gray</span>'.match(/<span class="bottom-border turquoise">gray</span><span class="bottom-border">|</span><span class="bottom-border steelblue">grey</span>/); <span class="code-comment js">["gray"]</span></code>
<code>'<span class="bottom-border steelblue">grey</span>'.match(/<span class="bottom-border turquoise">gray</span><span class="bottom-border">|</span><span class="bottom-border steelblue">grey</span>/); <span class="code-comment js">["grey"]</span></code>

<span class="bottom-border">Brackets</span> let you specify multiple possibilities for a single character.
<code>'<span class="bottom-border darkviolet">gr</span><span class="bottom-border springgreen">a</span><span class="bottom-border darkviolet">y</span>'.match(/<span class="bottom-border darkviolet">gr</span><span class="bottom-border">[</span><span class="bottom-border springgreen">a</span>|<span class="bottom-border tomato">e</span><span class="bottom-border">]</span><span class="bottom-border darkviolet">y</span>/); <span class="code-comment js">["gray"]</span></code>
<code>'<span class="bottom-border darkviolet">gr</span><span class="bottom-border tomato">e</span><span class="bottom-border darkviolet">y</span>'.match(/<span class="bottom-border darkviolet">gr</span><span class="bottom-border">[</span><span class="bottom-border springgreen">a</span>|<span class="bottom-border tomato">e</span><span class="bottom-border">]</span><span class="bottom-border darkviolet">y</span>/); <span class="code-comment js">["grey"]</span></code>

Actually, within the brackets, the or operator is implied:
<code>'<span class="bottom-border darkviolet">gr</span><span class="bottom-border springgreen">a</span><span class="bottom-border darkviolet">y</span>'.match(/<span class="bottom-border darkviolet">gr</span><span class="bottom-border">[</span><span class="bottom-border springgreen">a</span><span class="bottom-border tomato">e</span><span class="bottom-border">]</span><span class="bottom-border darkviolet">y</span>/); <span class="code-comment js">["gray"]</span></code>
<code>'<span class="bottom-border darkviolet">gr</span><span class="bottom-border tomato">e</span><span class="bottom-border darkviolet">y</span>'.match(/<span class="bottom-border darkviolet">gr</span><span class="bottom-border">[</span><span class="bottom-border springgreen">a</span><span class="bottom-border tomato">e</span><span class="bottom-border">]</span><span class="bottom-border darkviolet">y</span>/); <span class="code-comment js">["grey"]</span></code>

Say you wanted to match a character with any letter in the alphabet. You can just specify a range [<span class="bottom-border pink">a-z</span>]:
<code>'<span class="bottom-border pink">r</span>ed'.match(/[<span class="bottom-border pink">a-z</span>]/); <span class="code-comment js">["r"]</span></code>

As mentioned above, the brackets still match only **ONE** character. We need to specify <span class="bottom-border">how many characters to match</span>.

We could define a specific number of them as such:
<code>‘<span class="bottom-border pink">re</span>d’.match(/[a-z]<span class="bottom-border">{2}</span>/); <span class="code-comment js">["re"]</span></code>
<code>‘<span class="bottom-border pink">red</span>’.match(/[a-z]<span class="bottom-border">{3}</span>/); <span class="code-comment js">["red"]</span></code>
<code>‘red’.match(/[a-z]<span class="bottom-border">{4}</span>/); <span class="code-comment js">null</span></code>

Rather than a specific amount, we can specify a <span class="bottom-border blue">minimum</span> and <span class="bottom-border green">maximum</span>:

* {<span class="bottom-border blue">0</span>, <span class="bottom-border green">10</span>} = up to 10.
* {<span class="bottom-border blue">3</span>, <span class="bottom-border green">5</span>} = at least 3, at most 5.
* {<span class="bottom-border blue">0</span>, <span class="bottom-border green">1</span>} = either none or one. Can use ? as shorthand in this specific case.
* {<span class="bottom-border blue">0</span>, } = any amount. Can use * as shorthand in this specific case.
* {<span class="bottom-border blue">1</span>, } = 1 or more. Can use + as shorthand in this specific case.

What we really want is for there to be <span class="bottom-border">one or more letters</span>:
<code>'<span class="bottom-border pink">green</span>'.match(/[<span class="bottom-border pink">a-z</span>]<span class="bottom-border">+</span>/); <span class="code-comment js">["green"]</span></code>
<code>'P<span class="bottom-border pink">ink</span>'.match(/[<span class="bottom-border pink">a-z</span>]<span class="bottom-border">+</span>/); <span class="code-comment js">["ink"]</span></code>

Uh-oh, the capital letter wasn’t matched—need to increase the allowable range to capital letters, too:
<code>'<span class="bottom-border blue">P</span><span class="bottom-border pink">ink</span>'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border blue">A-Z</span>]+/); <span class="code-comment js">["Pink"]</span></code>

Or, make the regex <span class="bottom-border brown">case-insensitive</span>:
<code>'<span class="bottom-border pink">Pink</span>'.match(/[<span class="bottom-border pink">a-z</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink"]</span></code>

But what about:
<code>'<span class="bottom-border pink">Pink</span> Panther'.match(/[<span class="bottom-border pink">a-z</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink"]</span></code>

Why didn't it match the second word? It's because there's a space in the middle and that's not in the allowed range:
<code>'<span class="bottom-border pink">Pink</span><span class="bottom-border green"> </span><span class="bottom-border pink">Panther</span>'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border green"> </span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink Panther"]</span></code>

The meta-character <span class="bottom-border green">\s</span> matches not just a blank space, but <span class="bottom-border green">any whitespace (tabs, newlines, etc.)</span>:
<code>'<span class="bottom-border pink">Pink</span><span class="bottom-border green"> </span><span class="bottom-border pink">Panther</span>'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border green">\s</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink Panther"]</span></code>
<code>'<span class="bottom-border pink">Pink</span><span class="bottom-border green"> </span><span class="bottom-border pink">Panther</span><span class="bottom-border green"> </span>2'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border green">\s</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink Panther "]</span></code>

We need to allow numbers within the range also:
<code>'<span class="bottom-border pink">Pink</span><span class="bottom-border green"> </span><span class="bottom-border pink">Panther</span><span class="bottom-border green"> </span><span class="bottom-border blue">2</span>'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border green">\s</span><span class="bottom-border blue">0-9</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink Panther 2"]</span></code>

Within the brackets, order doesn't matter:
<code>'<span class="bottom-border pink">Pink</span><span class="bottom-border green"> </span><span class="bottom-border pink">Panther</span><span class="bottom-border green"> </span><span class="bottom-border blue">2</span>'.match(/[<span class="bottom-border pink">a-z</span><span class="bottom-border blue">0-9</span><span class="bottom-border green">\s</span>]+/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Pink Panther 2"]</span></code>

The meta-character <span class="bottom-border orange">\w</span> is the same as [A-Za-z0-9] so we can just do:
<code>'<span class="bottom-border orange">Pink</span><span class="bottom-border green"> </span><span class="bottom-border orange">Panther</span><span class="bottom-border green"> </span><span class="bottom-border orange">2</span>'.match(/[<span class="bottom-border orange">\w</span><span class="bottom-border green">\s</span>]+/); <span class="code-comment js">["Pink Panther 2"]</span></code>

Similarly, <span class="bottom-border steelblue">\d</span> is the same as [0-9]:
<code>'one<span class="bottom-border steelblue">23</span>four5'.match(/[<span class="bottom-border steelblue">\d</span>]+/); <span class="code-comment js">["23"]</span></code>
<code>'<span class="bottom-border steelblue">1</span>twothree4five'.match(/[<span class="bottom-border steelblue">\d</span>]+/); <span class="code-comment js">["1"]</span></code>

There is also a handy NOT operator. For escaped meta-characters, capitalizing the letter is the same as negating it.
<code>'<span class="bottom-border orange">one</span>23four5'.match(/[<span class="bottom-border orange">^\d</span>]+/); <span class="code-comment js">["one"]</span></code>
<code>'1<span class="bottom-border orange">twothree</span>4five'.match(/[<span class="bottom-border orange">\D</span>]+/); <span class="code-comment js">["twothree"]</span></code>

Inside the brackets, characters represent themselves, so [$.] matches the $ and ., but otherwise both are meta-characters that need to be escaped as \$ and \.:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border steelblue">45</span>'.match(/[<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">\d</span><span class="bottom-border turquoise">.</span>]+/); <span class="code-comment js">["$34.45"]</span></code>

But this is not strict enough:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.....</span><span class="bottom-border steelblue">45</span>'.match(/[<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">\d</span><span class="bottom-border turquoise">.</span>]+/); <span class="code-comment js">["$34.....45"]</span></code>
<code>'<span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border steelblue">456789</span>'.match(/[<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">\d</span><span class="bottom-border turquoise">.</span>]+/); <span class="code-comment js">["34.456789"]</span></code>
<code>'<span class="bottom-border tomato">$$$$$</span>'.match(/[<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">\d</span><span class="bottom-border turquoise">.</span>]+/); <span class="code-comment js">["$$$$$"]</span></code>

A better rule, using the escaped characters, is:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">45</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">["$34.45"]</span></code>
<code>'<span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">45</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">null</span></code>

We can also make the dollar sign <span class="bottom-border">optional</span>:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">45</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border">{0,1}</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">["$34.45"]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">45</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border">?</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">["$34.45"]</span></code>
<code>'<span class="bottom-border tomato">$$$$$$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">45</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border">?</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">["$34.45"]</span></code>
<code>'<span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">4567</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border">?</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">["34.45"]</span></code>

But now we have another problem--it's too strict:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">5</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{2}</span>/); <span class="code-comment js">null</span></code>

We can fix that by making a <span class="bottom-border">group</span> of characters <span class="bottom-border blue">optional</span>:
<code>'<span class="bottom-border steelblue">34</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34", undefined]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.", "."]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">0</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.0", ".0"]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">05</span>'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.05", ".05"]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">05</span>6'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.05", ".05"]</span></code>
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">05</span>6.09'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.05", ".05"]</span></code>

Creating groups results in multiple matches showing up in the results--one for the entire pattern, and one for each group. We can get rid of a group from the results by making it a <span class="bottom-border green">non-matching group</span>:
<code>'<span class="bottom-border tomato">$</span><span class="bottom-border steelblue">34</span><span class="bottom-border turquoise">.</span><span class="bottom-border darkviolet">05</span>6.09'.match(/<span class="bottom-border tomato">\$</span><span class="bottom-border steelblue">[\d]+</span><span class="bottom-border">(</span><span class="bottom-border green">?:</span><span class="bottom-border turquoise">\.</span><span class="bottom-border darkviolet">[\d]{0,2}</span><span class="bottom-border">)</span><span class="bottom-border blue">?</span>/); <span class="code-comment js">["$34.05"]</span></code>

<span class="emphasize">Capturing groups</span> let us reference parts of a string easily--for example, to reformat American date format to British:
<code>'07-04-1776'.replace(/<span class="bottom-border red">(\d{2})</span>-<span class="bottom-border white">(\d{2})</span>-<span class="bottom-border blue">(\d{4})</span>/, '<span class="bottom-border white">$2</span>-<span class="bottom-border red">$1</span>-<span class="bottom-border blue">$3</span>')<span class="code-comment js">04-07-1776</span></code>

<span class="emphasize bottom-border">Backreferences</span> let us refer to pattern groups numerically when there is a repetitive pattern:
<code>'07-04-1776'.replace(/<span class="bottom-border red">(\d{2})</span>-<span class="bottom-border">(\1)</span>-<span class="bottom-border blue">(\d{4})</span>/, '<span class="bottom-border white">$2</span>-<span class="bottom-border red">$1</span>-<span class="bottom-border blue">$3</span>')<span class="code-comment js">04-07-1776</span></code>
<br>

Regex is great for finding any part of a string that matches a pattern, but we can also use anchors to specify <span class="emphasize">which part</span> of the string should match a pattern.

We can make sure a string starts a certain way by using ^ (it has a different meaning than when it's inside a bracket):
<code>'unbearable'.match(/<span class="bottom-border pink">^bear</span><span class="bottom-border blue">\w*</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border pink">bear</span><span class="bottom-border blue">able</span>'.match(/<span class="bottom-border pink">^bear</span><span class="bottom-border blue">\w*</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["bearable"]</span></code>
<code>'forebear'.match(/<span class="bottom-border pink">^bear</span><span class="bottom-border blue">\w*</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'teddy bear'.match(/<span class="bottom-border pink">^bear</span><span class="bottom-border blue">\w*</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border pink">Bear</span>'.match(/<span class="bottom-border pink">^bear</span><span class="bottom-border blue">\w*</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Bear"]</span></code>

We can make sure a string ends a certain way by using $:
<code>'unbearable'.match(/<span class="bottom-border blue">\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'bearable'.match(/<span class="bottom-border blue">\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border blue">fore</span><span class="bottom-border pink">bear</span>'.match(/<span class="bottom-border blue">\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["forebear"]</span></code>
<code>'<span class="bottom-border blue">teddy </span><span class="bottom-border pink">bear</span>'.match(/<span class="bottom-border blue">\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["bear"]</span></code>
<code>'<span class="bottom-border pink">Bear</span>'.match(/<span class="bottom-border blue">\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Bear"]</span></code>

Using both, we can make sure that something matches a pattern and **ONLY** that pattern:
<code>'unbearable'.match(/<span class="bottom-border blue">^\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'bearable'.match(/<span class="bottom-border blue">^\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border blue">fore</span><span class="bottom-border pink">bear</span>'.match(/<span class="bottom-border blue">^\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["forebear"]</span></code>
<code>'teddy bear'.match(/<span class="bottom-border blue">^\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">null</span></code>
<code>'<span class="bottom-border pink">Bear</span>'.match(/<span class="bottom-border blue">^\w*</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span>); <span class="code-comment js">["Bear"]</span></code>

<p class="no-bottom-spacing">What if a text contains more than one line?</p>
<pre class="no-top-spacing"><code>var multiLine = '<span class="bottom-border blue">Grizzly</span><span class="bottom-border darkviolet"> </span><span class="bottom-border pink">Bear</span><span class="bottom-border orange">\n</span>
              <span class="bottom-border blue">Mama</span><span class="bottom-border darkviolet"> </span><span class="bottom-border pink">Bear</span><span class="bottom-border orange">\n</span>
              Mama Whale<span class="bottom-border orange">\n</span>
              Killer Whale<span class="bottom-border orange">\n</span>
              forebear<span class="bottom-border orange">\n</span>
              <span class="bottom-border blue">teddy</span><span class="bottom-border darkviolet"> </span><span class="bottom-border pink">bear</span><span class="bottom-border orange">\n</span>
              Bear Cub';

multiLine.match(/<span class="bottom-border blue">^\w+</span><span class="bottom-border darkviolet">\s</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border brown">i</span><span class="bottom-border green">g</span>); <span class="code-comment js">null</span>
</code></pre>

That didn't work because the ^ and $ anchors treated the whole string as one, rather than doing individual matches for each line.

The <span class="bottom-border orange">m</span> modifier fixes that:
<code>multiLine.match(/<span class="bottom-border blue">^\w+</span><span class="bottom-border darkviolet">\s</span><span class="bottom-border pink">bear$</span>/<span class="bottom-border orange">m</span><span class="bottom-border brown">i</span><span class="bottom-border green">g</span>); <span class="code-comment js">["Grizzly Bear", "Mama Bear", "teddy bear"]</span></code>
<br>
<br>

At this this point, we've covered all the most common rules for regex. Let's discuss <span class="emphasize">lookarounds</span>, though they are not very commonly used.

Look arounds let you insert additional logic into your regex. Basically, you look for a pattern only if it follows or is followed by another pattern.

Want to only include matches if there is another string <span class="emphasize">ahead of</span> it? Use positive lookahead <span class="bottom-border">(?=)</span>:
<code>'Say <span class="bottom-border pink">hi</span><span class="bottom-border orange"> before you say </span><span class="bottom-border green">bye</span>'.match(/<span class="bottom-border pink">hi</span><span class="bottom-border">(?=</span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border green">bye</span><span class="bottom-border">)</span>/); <span class="code-comment js">["hi"]</span></code>
<code>'Do not say <span class="bottom-border green">bye</span><span class="bottom-border orange"> before you say </span><span class="bottom-border pink">hi</span>'.match(/<span class="bottom-border pink">hi</span><span class="bottom-border">(?=</span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border green">bye</span><span class="bottom-border">)</span>/); <span class="code-comment js">null</span></code>

Want to do the opposite? Use negative lookahead <span class="bottom-border">(?!)</span>:
<code>'Say <span class="bottom-border pink">hi</span><span class="bottom-border orange"> before you say </span><span class="bottom-border green">bye</span>'.match(/<span class="bottom-border pink">hi</span><span class="bottom-border">(?!</span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border green">bye</span><span class="bottom-border">)</span>/); <span class="code-comment js">null</span></code>
<code>'Do not say <span class="bottom-border green">bye</span><span class="bottom-border orange"> before you say </span><span class="bottom-border pink">hi</span>'.match(/<span class="bottom-border pink">hi</span><span class="bottom-border">(?!</span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border green">bye</span><span class="bottom-border">)</span>/); <span class="code-comment js">["hi"]</span></code>

To include a match only if another string is <span class="emphasize">behind</span> it, Use positive lookbehind <span class="bottom-border">(?<=)</span>:
<code>'Look <span class="bottom-border pink">behind</span><span class="bottom-border orange"> before you look </span><span class="bottom-border green">ahead</span>'.match(/<span class="bottom-border green">ahead</span><span class="bottom-border">(?<=<span class="bottom-border pink">behind</span></span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border">)</span>/); <span class="code-comment js">["ahead"]</span></code>
<code>'Look <span class="bottom-border green">ahead</span><span class="bottom-border orange"> before you look </span><span class="bottom-border pink">behind</span>'.match(/<span class="bottom-border green">ahead</span><span class="bottom-border">(?<=<span class="bottom-border pink">behind</span></span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border">)</span>/); <span class="code-comment js">null</span></code>

Want to do the opposite? Use negative lookahead <span class="bottom-border">(?<!)</span>:
<code>'Do not look <span class="bottom-border pink">behind</span><span class="bottom-border orange"> before you look </span><span class="bottom-border green">ahead</span>'.match(/<span class="bottom-border green">ahead</span><span class="bottom-border">(?<!<span class="bottom-border pink">behind</span></span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border">)</span>/); <span class="code-comment js">null</span></code>
<code>'Do not look <span class="bottom-border green">ahead</span><span class="bottom-border orange"> before you look </span><span class="bottom-border pink">behind</span>'.match(/<span class="bottom-border green">ahead</span><span class="bottom-border">(?<!<span class="bottom-border pink">behind</span></span><span class="bottom-border orange">[\w\s]*</span><span class="bottom-border">)</span>/); <span class="code-comment js">["ahead"]</span></code>
<br>
<br>
Javascript's implementation of regex does not allow for atomic operations but let's discuss it for the sake of completeness to see what it might do.

An **atomic group** is a non-capturing group that exits the group and throws away all alternatives after the first match of the pattern inside the group, so backtracking is disallowed. This makes the matching process faster since the engine only ever goes forward (visiting each letter only once).

By default, regex matches are treated as non-atomic groups so they allow backtracking. The regex engine looks for the first match, then if the matching ahead fails, it will backtrack and find the next match, until a match for the entire expression is found or all possibilities are exhausted.

<code>'<span class="bottom-border green">cart</span><span class="bottom-border orange">s</span>'.match(/(<span class="bottom-border blue">car</span>|<span class="bottom-border green">cart</span>)<span class="bottom-border orange">s</span>/); <span class="code-comment js">["carts", "cart"]</span></code>

In the example above, the regex engine will first try to match the string to <span class="bottom-border blue">car</span><span class="bottom-border orange">s</span> but fail at <span class="bottom-border orange">s</span>, then backtrack and try to match the string to <span class="bottom-border green">cart</span><span class="bottom-border orange">s</span>, for which it will successfully find matches.


<code>'<span class="bottom-border green">cart</span><span class="bottom-border orange">s</span>'.match(/(<span class="bottom-border">?></span><span class="bottom-border blue">car</span>|<span class="bottom-border green">cart</span>)<span class="bottom-border orange">s</span>/); <span class="code-comment js">null</span></code>

When I use an <span class="bottom-border">atomic group</span>, however, the engine never backtracks to try the <span class="bottom-border green">second alternative</span>, and just fails to find a match.

<code>'<span class="bottom-border green">cart</span><span class="bottom-border orange">s</span>'.match(/(<span class="bottom-border">?></span><span class="bottom-border red">fart</span>|<span class="bottom-border green">cart</span>)<span class="bottom-border orange">s</span>/); <span class="code-comment js">["carts", "cart"]</span></code>

Because the <span class="bottom-border red">first alternative</span> was never even evaluated--the <span class="bottom-border green">second one</span> is the only path the engine follows, and never needs to backtrack to find a match.
<br>
<br>

<p class="no-bottom-spacing">Now that you know the rules, this cross-lingual cheat sheet should be enough to fill any gaps:</p>
<iframe style="height:700px" src="https://docs.google.com/spreadsheets/d/10YWUN5hCx3B98BCULgvX3OSL-3kF0k1XPbcGPF3e2J4/pubhtml?gid=0&amp;single=true&amp;widget=true&amp;headers=false"></iframe>

### Further Reading

1. [Regular Expression Matching Can Be Simple And Fast](https://swtch.com/~rsc/regexp/regexp1.html)
2. [How Google Code Search Worked](https://swtch.com/~rsc/regexp/regexp4.html)

### Sources

1. [Regular Expressions for the Rest of Us](https://davidwalsh.name/regular-expressions-rest)
2. [How to Become a Regular Expression Power User](https://www.memberpress.com/how-to-become-a-regular-expression-power-user/)
3. [Regex 101](https://regex101.com/)
4. [MDN Regex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
5. [Stack Overflow answer](http://stackoverflow.com/questions/2973436/regex-lookahead-lookbehind-and-atomic-groups)
