---
layout: post
title: Regex
description: Regular expressions in 1 hour or less
categories: [Technology]
tags: [programming, string manipulation]
image: /assets/blog/img/find-dialog.png
---

    /^([^,]+),\s([A-Z]{2})(?:\s(\d{5}))?$/

When you first encounter regular expressions ("regex") like the one above, they can seem very foreign. The random symbols look more like something from Stargate than from English, but understanding regex is actually quite simple!

# What?

Regex is a sequence of characters that form a search pattern that can be either extremely broad or specific. It is a formalized description of a regular language [created by Steven Kleene in the 1950’s](https://en.wikipedia.org/wiki/Regular_language). The theory behind is pretty cool but honestly not very relevant to our understanding.

For our purposes, regex is a way to match strings with patterns using concise code that is common across programming languages.*

# Why?

Any search you do probably at some level uses regexp to find a match. Regex is a combination of characters and meta-characters used for:

1. **Matching:** Determine if a string matches some format (e.g., a phone number, email, address or credit card number)
2. **Replacement:** Find and replace patterns in a string (e.g., all whitespaces, common mispellings, etc.)
3. **Extraction:** Extract specific information (e.g., zip codes, titles, etc.)

Using regex over code has two main advantages:

1. **Portability:** Almost every major language has a regular expression library with standardized syntax so you can learn it once, use it everywhere
2. **Concise:** While it may not seem like it at first, regex is much easier to write and read than the equivalent logic in code

Some common use cases are:

1. Verify the structure of strings (e.g. input forms)
2. Extract information form strings (e.g. zip code from an address)
3. Search / replace / rearrange parts of the string (e.g. DD/MM/YYYY to MM/DD/YYYY)
4. Split a string into tokens

# How?

Let's learn Regex with Javascript and then we can port that knowledge to other languages as needed.*

If you know the pattern beforehand, you can declare a regex using a literal. Nothing magical here--just like wrapping text in quotation marks indicates a string, or brackets indicate an array, or curly braces indicate an object, wrapping text in forward slashes indicates a regex:

    var regex = /pattern/

If you won't know the pattern till runtime (e.g. because the user will input it), you can use the RegExp constructor instead:

    var userInput = 'pattern';
    var regex = new RegExp(userInput);

The most basic operations you can do resemble the 'Ctrl / Cmd + F' operations most people are already familiar with.

![Find and Replace](/assets/blog/img/find-dialog.png)

<pre><code>var string = 'Zoo';
var regex = /Zoo/;

string.match(regex); <span class="code-comment">// &rarr; ["Zoo"]</span>

'Some other word'.match(regex); <span class="code-comment">// &rarr; null</span>
</code></pre>

Regex returns an array of the matched characters if there are any, or null if there are no matches.

By default, partial matches are allowed:
<code>'Zoolander'.match(regex); <span class="code-comment">// &rarr; ["Zoo"]</span></code>

To match whole words, use \b to define the word boundary:
<pre><code>'Zoolander'.match(/\bZoo\b/); <span class="code-comment">// &rarr; null</span>

'San Francisco Zoo'.match(/\bZoo\b/); <span class="code-comment">// &rarr; ["Zoo"]</span></code></pre>

By default, matches are case sensitive. Adding the *i* modifier makes the match case insensitive:
<pre><code>'zoo'.match(regex); <span class="code-comment">// &rarr; null</span>

'Zoo'.match(/Zoo/i); <span class="code-comment">// &rarr; ["Zoo"]</span>

'zoo'.match(/Zoo/i); <span class="code-comment">// &rarr; ["zoo"]</span></code></pre>

There are a few more modifiers--they always go after the ending forward slash.

By default, regex is like a *Find Next*--it stops looking as soon as a match is found. Adding the g modifier makes it more like a *Find All*:
<code>'Zoolander went to the SF Zoo'.match(regex); <span class="code-comment">// &rarr; ["Zoo"]</span></code>
<code>'Zoolander went to the SF Zoo'.match(/Zoo/g); <span class="code-comment">// &rarr; ["Zoo", "Zoo"]</span></code>

Now, let's get into the cooler stuff regex can do that goes beyond a simple *Find* function.

For one, you can search for match two separate patterns using the or operator:
<code>'gray'.match(/gray|grey/); <span class="code-comment">// &rarr; ["gray"]</span></code>
<code>'grey'.match(/gray|grey/); <span class="code-comment">// &rarr; ["grey"]</span></code>

Brackets let you specify multiple possibilities for a single character.
<code>'gray'.match(/gr[a|e]y/); <span class="code-comment">// &rarr; ["gray"]</span></code>
<code>'grey'.match(/gr[a|e]y/); <span class="code-comment">// &rarr; ["grey"]</span></code>

Say you wanted to match a character with any letter in the alphabet. You can just specify a range [a-z]:
<code>'red'.match(/[a-z]/); <span class="code-comment">// &rarr; ["r"]</span></code>

As mentioned above, the brackets still match only **ONE** character. We need to specify how many characters to match.

We could define a specific number of them as such:
<code>‘red’.match(/[a-z]{2}/); <span class="code-comment">// &rarr; ["re"]</span></code>
<code>‘red’.match(/[a-z]{3}/); <span class="code-comment">// &rarr; ["red"]</span></code>
<code>‘red’.match(/[a-z]{4}/); <span class="code-comment">// &rarr; null</span></code>

Rather than a specific amount, we can specify a minimum and maximum:

* {0, 10} = up to 10.
* {3, 5} = at least 3, at most 5.
* {0, 1} = either none or one. Can use ? as shorthand in this specific case.
* {0, } = any amount. Can use * as shorthand in this specific case.
* {1, } = 1 or more. Can use + as shorthand in this specific case.

What we really want is for there to be one or more letters:
<code>'green'.match(/[a-z]+/); <span class="code-comment">// &rarr; ["green"]</span></code>
<code>'Pink'.match(/[a-z]+/); <span class="code-comment">// &rarr; ["ink"]</span></code>

Uh-oh, the capital letter wasn’t matched—need to increase the allowable range to capital letters, too:
<code>'Pink'.match(/[a-zA-Z]+/); <span class="code-comment">// &rarr; ["Pink"]</span></code>

Or, make the regex case-insensitive with:
<code>'Pink'.match(/[a-z]+/i); <span class="code-comment">// &rarr; ["Pink"]</span></code>

But what about:
<code>'Pink Panther'.match(/[a-z]+/i); <span class="code-comment">// &rarr; ["Pink"]</span></code>

Why didn't it match the second word? It's because there's a space in the middle and that's not in the allowed range:
<code>'Pink Panther'.match(/[a-z ]+/i); <span class="code-comment">// &rarr; ["Pink Panther"]</span></code>

The meta-character \s matches not just a blank space, but any whitespace (tabs, newlines, etc.):
<code>'Pink Panther'.match(/[a-z\s]+/i); <span class="code-comment">// &rarr; ["Pink Panther"]</span></code>
<code>'Pink Panther 2'.match(/[a-z\s]+/i); <span class="code-comment">// &rarr; ["Pink Panther "]</span></code>

We need to allow numbers within the range also:
<code>'Pink Panther 2'.match(/[a-z\s0-9]+/i); <span class="code-comment">// &rarr; ["Pink Panther 2"]</span></code>

Within the brackets, order doesn't matter:
<code>'Pink Panther 2'.match(/[a-z0-9\s]+/i); <span class="code-comment">// &rarr; ["Pink Panther 2"]</span></code>

The meta-character \w is the same as [A-Za-z0-9] so we can just do:
<code>'Pink Panther 2'.match(/[\w\s]+/); <span class="code-comment">// &rarr; ["Pink Panther 2"]</span></code>

Similarly, \d is the same as [0-9]:
<code>'one23four5'.match(/[\d]+/); <span class="code-comment">// &rarr; ["23"]</span></code>
<code>'1twothree4five'.match(/[\d]+/); <span class="code-comment">// &rarr; ["1"]</span></code>

There is also a handy NOT operator. For escaped meta-characters, capitalizing the letter is the same as negating it.
<code>'one23four5'.match(/[^\d]+/); <span class="code-comment">// &rarr; ["one"]</span></code>
<code>'1twothree4five'.match(/[\D]+/); <span class="code-comment">// &rarr; ["twothree"]</span></code>

Inside the brackets, characters represent themselves, so [$.] matches the $ and ., but otherwise both are meta-characters that need to be escaped as \$ and \.:
<code>'$34.45'.match(/[$\d.]+/); <span class="code-comment">// &rarr; ["$34.45"]</span></code>

But this is not strict enough:
<code>'$34.....45'.match(/[$\d.]+/); <span class="code-comment">// &rarr; ["$34.....45"]</span></code>
<code>'34.456789'.match(/[$\d.]+/); <span class="code-comment">// &rarr; ["34.456789"]</span></code>
<code>'$$$$$'.match(/[$\d.]+/); <span class="code-comment">// &rarr; ["$$$$$"]</span></code>

A better rule, using the escaped characters, is:
<code>'$34.45'.match(/\$[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; ["$34.45"]</span></code>
<code>'34.45'.match(/\$[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; null</span></code>

We can also make the dollar sign optional:
<code>'$34.45'.match(/\${0,1}[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; ["$34.45"]</span></code>
<code>'$34.45'.match(/\$?[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; ["$34.45"]</span></code>
<code>'$$$$$$34.45'.match(/\$?[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; ["$34.45"]</span></code>

But now we have another problem--it's too strict:
<code>'$34'.match(/\$[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; null</span></code>
<code>'$34.5'.match(/\$[\d]+\.[\d]{2}/); <span class="code-comment">// &rarr; null</span></code>

We can fix that by making a **group** of characters optional:
<code>'34'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34", undefined]</span></code>
<code>'$34'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.", "."]</span></code>
<code>'$34.0'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.0", ".0"]</span></code>
<code>'$34.05'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.05", ".05"]</span></code>
<code>'$34.056'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.05", ".05"]</span></code>
<code>'$34.056.09'.match(/\$[\d]+(\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.05", ".05"]</span></code>

Creating groups results in multiple matches showing up in the results--one for the entire pattern, and one for each group. We can get rid of a group from the results by making it a non-matching group:
<code>'$34.056.09'.match(/\$[\d]+(?:\.[\d]{0,2})?/); <span class="code-comment">// &rarr; ["$34.05"]</span></code>

Regex is great for finding the part of a string that matches a pattern, but we can also ensure the entire string matches a pattern using anchors.

We can make sure a string starts a certain way by using ^ (it has a different meaning than when it's inside a bracket):
<code>'unbearable'.match(/^bear\w*/i); <span class="code-comment">// &rarr; null</span></code>
<code>'bearable'.match(/^bear\w*/i); <span class="code-comment">// &rarr; ["bearable"]</span></code>
<code>'forebear'.match(/^bear\w*/i); <span class="code-comment">// &rarr; null</span></code>
<code>'teddy bear'.match(/^bear\w*/i); <span class="code-comment">// &rarr; null</span></code>
<code>'Bear'.match(/^bear\w*/i); <span class="code-comment">// &rarr; ["Bear"]</span></code>

We can make sure a string ends a certain way by using $:
<code>'unbearable'.match(/\w*bear$/i); <span class="code-comment">// &rarr; null</span></code>
<code>'bearable'.match(/\w*bear$/i); <span class="code-comment">// &rarr; null</span></code>
<code>'forebear'.match(/\w*bear$/i); <span class="code-comment">// &rarr; ["forebear"]</span></code>
<code>'teddy bear'.match(/\w*bear$/i); <span class="code-comment">// &rarr; ["bear"]</span></code>
<code>'Bear'.match(/\w*bear$/i); <span class="code-comment">// &rarr; ["Bear"]</span></code>

Using both, we can make sure that something matches a pattern and **ONLY** that pattern:
<code>'unbearable'.match(/^\w*bear$/i); <span class="code-comment">// &rarr; null</span></code>
<code>'bearable'.match(/^\w*bear$/i); <span class="code-comment">// &rarr; null</span></code>
<code>'forebear'.match(/^\w*bear$/i); <span class="code-comment">// &rarr; ["forebear"]</span></code>
<code>'teddy bear'.match(/^\w*bear$/i); <span class="code-comment">// &rarr; null</span></code>
<code>'Bear'.match(/^\w*bear$/i); <span class="code-comment">// &rarr; ["Bear"]</span></code>

What if a text contains more than one line?
<pre><code>var multiLine = 'Grizzly Bear\n
              Mama Bear\n
              Mama Whale\n
              Killer Whale\n
              forebear\n
              teddy bear\n
              Bear Cub';

multiLine.match(/^\w+\sbear$/ig); <span class="code-comment">// &rarr; null</span>
</code></pre>

That didn't work because the ^ and $ anchors treated the whole string as one, rather than doing individual matches for each line. The m modifier fixes that:
<code>multiLine.match(/^\w+\sbear$/mig); <span class="code-comment">// &rarr; ["Grizzly Bear", "Mama Bear", "teddy bear"]</span></code>


https://swtch.com/~rsc/regexp/regexp1.html

https://swtch.com/~rsc/regexp/regexp4.html

https://davidwalsh.name/regular-expressions-rest

https://regex101.com/

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp

https://www.memberpress.com/how-to-become-a-regular-expression-power-user/
